# Continuation support for Java
This project contains libary, tools and examples to develop Java applications using continuations. 

According to Wikipedia "a continuation is an abstract representation of the control state of a computer program; a continuation reifies the program control state, i.e. the continuation is a data structure that represents the computational process at a given point in the process's execution; the created data structure can be accessed by the programming language, instead of being hidden in the runtime environment"

In other words, continuation allows you to capture execution state of the program (local variables, execution stack, program counters etc.) at the certain places and later resume execution from the saved point. Unfortunately, Java has no support for first-class continuations, but it can be added via bytecode instrumentation (like this library did)

The project is based on the completely reworked Apache Jakarta-Commons JavaFlow project (http://commons.apache.org/sandbox/commons-javaflow/). Below is a list of major changes:

1. Original JavaFlow instruments bytecode of each and every method available for tooling to add Continuations support. This adds significant overhead to both code size and execution time. The reworked version requires developer to mark Continuation-aware classes/methods explicitly with annotations.
2. Code is updated to use new bytecode instrumentation tools (ObjectWeb ASM 5.x); support for BCEL is discontinued 
3. Codebase is split to separate modules: run-time API, instrumentation provider SPI, offline instrumentation tools (Maven, Ant, command-line), run-time instrumentation JavaAgent, utilities and examples
4. The library adds support for recent Java features like lambdas and dynamic dispatch

# Maven

You have to add the following configuration to enable build-time instrumentation of classes during Maven build:
```xml
	<dependencies>
		<dependency>
			<groupId>net.tascalate.javaflow</groupId>
			<artifactId>net.tascalate.javaflow.api</artifactId>
			<version>${project.version}</version>
		</dependency>
		...
	</dependencies>

	<build>
		<plugins>
			<plugin>
				<groupId>org.apache.maven.plugins</groupId>
				<artifactId>maven-compiler-plugin</artifactId>
				<configuration>
					<source>1.8</source>
					<target>1.8</target>
				</configuration>
			</plugin>
			<plugin>
				<groupId>net.tascalate.javaflow</groupId>
				<artifactId>net.tascalate.javaflow.tools.maven</artifactId>
				<version>2.0-SNAPSHOT</version>
				<executions>
					<execution>
						<phase>process-classes</phase>
						<goals>
							<goal>javaflow-enhance</goal>
						</goals>
					</execution>
				</executions>
			</plugin>
		</plugins>
	</build>
```
Note that if you are using continuations with Java 1.8 lambdas then you need to add Tascalate JavaFlow instrumentation agent at run-time as command-line option, while lambda-related classes are generated by JVM on the fly and there is no other way to instrument them.

Please refer to [pom.xml](./blob/master/net.tascalate.javaflow.examples/pom.xml) in examples project for typical Maven configuration

# Ant

There is a separate Ant task for applying JavaFlow instrumentation at build-time. 

It's possibe to instrument compiled Java classes as below:
```xml
    <target name="instrument-classes" description="JavaFlow Instrumentation" depends="compile">
        <taskdef name="javaflow" classname="org.apache.commons.javaflow.ant.AntRewriteTask" 
        classpathref="ant-lib-classpath"/>
        <echo message="JavaFlow instrumentation of compiled classes in ${classes.dir}" />
        <javaflow srcdir="${classes.dir}" destdir="${i-classes.dir}" classpathref="classpath"/>
    </target>
```
... as well as re-write packaged JAR file:
```xml
<target name="instrument-jar" description="JavaFlow Instrumentation" depends="jar">
        <taskdef name="javaflow" classname="org.apache.commons.javaflow.ant.AntRewriteTask" 
        classpathref="ant-lib-classpath"/>
        <echo message="JavaFlow instrumentation of compiled classes in ${jar.dir}/${ant.project.name}.jar" />
        <javaflow srcdir="${jar.dir}" destdir="${i-jar.dir}" classpathref="classpath"/>
    </target>
```
You may take a look at [examples project](./tree/master/net.tascalate.javaflow.examples) for complete configuration template. 
